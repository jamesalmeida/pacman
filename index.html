<!DOCTYPE html>
<html>
<head>
    <title>Pac-Man</title>
    <link rel="icon" type="image/x-icon" href="public/favicon.ico">
    <style>
        body {
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Ensure full viewport height */
            margin: 0; /* Remove default body margin */
            font-family: monospace; /* Added monospace font */
            font-size: 13px;
            color: white;
        }
        #gameContainer {
            display: flex;
            flex-direction: column; /* Stack info area and canvas vertically */
            align-items: center; /* Center items horizontally within the container */
        }
        #infoAreaTop {
            margin-bottom: 10px; /* Space between score and canvas */
            width: 420px; /* Match canvas width for alignment */
            display: flex;
            flex-direction: row;
            align-items: flex-start; /* Align tops of child blocks */
            position: relative; /* For positioning highScoreArea */
        }
        /* Styles for the new score display structure */
        #player1ScoreArea {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 20px;
        }

        #highScoreArea {
            display: flex;
            flex-direction: column;
            align-items: center; /* Aligns "HIGH SCORE" and its value to the center */
            position: absolute;
            left: 50%; /* Center horizontally within #infoAreaTop */
            transform: translateX(-50%);
            top: 0; /* Align with the top of #infoAreaTop's content */
        }

        #oneUpText, #highScoreLabel {
            margin-bottom: 2px; /* Small space between label and value */
        }

        #scoreValue, #highScoreValueDisplay {
            /* Values inherit text styling, specific styling can be added here if needed */
        }
        /* End of new score display styles */
        #infoAreaFooter {
            margin-top: 10px; /* Space between score and canvas */
            width: 420px; /* Match canvas width for alignment */
            display: flex; /* Added for centering children */
            flex-direction: column; /* Stack children vertically */
            /* align-items: center; */ /* Removed to allow children to self-align */
            justify-content: center;
        }
        #livesDisplay {
            margin-left: 20px;
            display: flex;
            align-self: flex-start; /* Align this item to the start (left) */
        }
        .lifeIcon {
            margin-right: 5px;
        }
        #insertCreditArea {
            display: flex;
            flex-direction: column;
            align-items: center; /* Centers its internal spans */
            align-self: center; /* Center this block within the parent */
            display: none; /* Hide by default */
        }
        /* Optional: if you want to style the spans specifically */
        /* #insertCreditLabel, #insertCreditHelpText { */
        /* styles here */
        /* } */
        canvas {
            border: 1px solid black;
            background: black;
            /* Style dimensions will be set via JS to control apparent size */
        }
        #githubLink {
            position: fixed; /* Position relative to the viewport */
            bottom: 0px; /* 10px from the bottom */
            right: 0px; /* 10px from the right */
            z-index: 1000; /* Ensure it's above other content */
            padding: 10px;
            border-top-left-radius: 10px;
            background-color: blue;
        }
        a {
            color: white;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="infoAreaTop">
            <div id="player1ScoreArea">
                <span id="oneUpText">1UP</span>
                <span id="scoreValue">0</span>
            </div>
            <div id="highScoreArea">
                <span id="highScoreLabel">HIGH SCORE</span>
                <span id="highScoreValueDisplay">12410</span>
            </div>
        </div>
        <canvas id="gameCanvas" width="420" height="420"></canvas>
        <div id="infoAreaFooter">
            <div id="livesDisplay"></div>
            <div id="insertCreditArea">
                <span id="insertCreditLabel">INSERT CREDIT</span>
                <span id="insertCreditHelpText">(Press 1)</span>
            </div>
        </div>
        <div id="githubLink"><a href="https://github.com/jamesalmeida/pacman">github.com/jamesalmeida/pacman</a></div>
    </div>

    <!-- Audio Elements -->
    <audio id="gameStart" src="public/audio/game_start.mp3" preload="auto"></audio>
    <audio id="chomp" src="public/audio/chomp.mp3" preload="auto"></audio>
    <audio id="death" src="public/audio/death.mp3" preload="auto"></audio>
    <audio id="ghostEaten" src="public/audio/ghost_eaten.mp3" preload="auto"></audio>
    <audio id="powerPellet" src="public/audio/power_pellet.mp3" preload="auto"></audio>
    <audio id="levelComplete" src="public/audio/level_complete.mp3" preload="auto"></audio>
    <audio id="backgroundMusic" src="public/audio/background_music.mp3" preload="auto" loop></audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Adjust for retina displays
        const scale = window.devicePixelRatio || 1;
        const baseWidth = 420;
        const baseHeight = 420;

        canvas.width = baseWidth * scale;
        canvas.height = baseHeight * scale;
        canvas.style.width = baseWidth + 'px';
        canvas.style.height = baseHeight + 'px';

        ctx.scale(scale, scale);
        
        window.gameOver = false; // Initialize gameOver flag
        let mouthOpen = true; // Track if Pac-Man's mouth is open or closed
        let mouthFrameCounter = 0; // For controlling mouth animation speed
        const MOUTH_ANIMATION_FRAMES = 10; // Toggle mouth every 10 frames (10 * 20ms = 200ms)
        let extraLives = 3; // Initialize extraLives (e.g., 3 extra lives means 4 total chances)
        let energizerActive = false;
        let energizerTimer = 0;
        const energizerDuration = 10000; // 10 seconds
        const ENERGIZER_FLASH_START_TIME = 7000; // Start flashing 3 seconds before energizer ends (10000 - 3000)
        const GHOST_FLASH_INTERVAL = 200; // Flash every 200ms
        let ghostFlashOn = false; // State for ghost flashing
        let lastGhostFlashTime = 0;
        let energizerVisible = true; // Added for blinking effect
        let energizerBlinkTimer = 0; // Timer for blinking
        const ENERGIZER_BLINK_INTERVAL = 400; // Blink every 0.5 second (500ms)
        let consecutiveGhostsEaten = 0;
        let levelClearPauseActive = false; // Flag for level clear pause
        let scoreForNextExtraLife = 10000; // Tracks the next score milestone for an extra life
        const PINKY_TARGET_OFFSET = 4; // Pinky tries to position 4 tiles ahead of Pacman
        const GHOST_SCATTER_MODE = false; // For future implementation of scatter/chase modes

        let pacmanDeathAnimationActive = false;
        let pacmanDeathAnimationProgress = 0; // Goes from 0 to 1
        const PACMAN_DEATH_ANIMATION_DURATION_MS = 1500; // 1.5 seconds

        let temporaryScoreDisplays = []; // To hold scores shown on ghost eats
        const SCORE_DISPLAY_DURATION = 2000; // 2 seconds

        // Function to determine target tile for each ghost based on their color and current state
        function getGhostTarget(ghost, pacmanX, pacmanY, pacmanDir) {
            // If ghost is scared or eyes, it doesn't have a target tile
            if (ghost.isScared || ghost.isEyes) {
                return null;
            }
            
            const pacmanTileX = Math.floor(pacmanX / tileSize);
            const pacmanTileY = Math.floor(pacmanY / tileSize);
            
            // Convert pixel positions to tile positions
            const ghostTileX = Math.floor(ghost.x / tileSize);
            const ghostTileY = Math.floor(ghost.y / tileSize);
            
            switch (ghost.color) {
                case 'red': // Blinky - directly chases Pacman
                    return { x: pacmanTileX, y: pacmanTileY };
                    
                case 'pink': // Pinky - targets 4 tiles ahead of Pacman
                    let targetX = pacmanTileX;
                    let targetY = pacmanTileY;
                    
                    // Calculate target based on Pacman's direction
                    if (pacmanDir === 'up') {
                        targetY -= PINKY_TARGET_OFFSET;
                        // Recreate the original game's bug where Up direction also shifts left by 4 tiles
                        targetX -= PINKY_TARGET_OFFSET;
                    } else if (pacmanDir === 'down') {
                        targetY += PINKY_TARGET_OFFSET;
                    } else if (pacmanDir === 'left') {
                        targetX -= PINKY_TARGET_OFFSET;
                    } else if (pacmanDir === 'right') {
                        targetX += PINKY_TARGET_OFFSET;
                    }
                    
                    return { x: targetX, y: targetY };
                    
                case 'cyan': // Inky - uses both Pacman and Blinky positions
                    // First get position 2 tiles ahead of Pacman
                    let pivotX = pacmanTileX;
                    let pivotY = pacmanTileY;
                    
                    if (pacmanDir === 'up') {
                        pivotY -= 2;
                        // Recreate the same bug as Pinky
                        pivotX -= 2;
                    } else if (pacmanDir === 'down') {
                        pivotY += 2;
                    } else if (pacmanDir === 'left') {
                        pivotX -= 2;
                    } else if (pacmanDir === 'right') {
                        pivotX += 2;
                    }
                    
                    // Find Blinky's position
                    const blinky = ghosts.find(g => g.color === 'red');
                    if (!blinky) return { x: pivotX, y: pivotY }; // Fallback
                    
                    const blinkyTileX = Math.floor(blinky.x / tileSize);
                    const blinkyTileY = Math.floor(blinky.y / tileSize);
                    
                    // Double the vector from Blinky to the pivot point
                    const vectorX = pivotX - blinkyTileX;
                    const vectorY = pivotY - blinkyTileY;
                    
                    return {
                        x: pivotX + vectorX,
                        y: pivotY + vectorY
                    };
                    
                case 'orange': // Clyde - random movement, no specific target
                    return null;
                    
                default:
                    return null;
            }
        }

        // Maze layout (1 = wall, 0 = path/dot, 2 = eaten dot, 3 = ghost spawn point, 4 = Energizer)
        const originalMaze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], 
            [1,0,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,1,2,1,2,1,1,1,1,0,1,1,1,1],
            [1,1,1,1,0,1,2,2,2,2,2,2,2,2,2,1,0,1,1,1,1], 
            [1,1,1,1,0,1,2,1,1,3,3,3,1,1,2,1,0,1,1,1,1], 
            [2,2,2,2,0,2,2,1,1,3,3,3,1,1,2,2,0,2,2,2,2], 
            [1,1,1,1,0,1,2,1,1,1,1,1,1,1,2,1,0,1,1,1,1], 
            [1,1,1,1,0,1,2,2,2,2,2,2,2,2,2,1,0,1,1,1,1],
            [1,1,1,1,0,1,2,1,1,1,1,1,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1], 
            [1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1], 
            [1,0,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,1], 
            [1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        const maze = JSON.parse(JSON.stringify(originalMaze));
        // Add power pellets at specific locations
        maze[2][1] = 4;
        maze[2][19] = 4;
        maze[15][1] = 4;
        maze[15][19] = 4;
        
        const tileSize = 20; // Updated tileSize for 20x20 grid
        const GHOST_NORMAL_SPEED = 1.5;
        const GHOST_SCARED_SPEED = 0.75; // Slower speed when scared
        let pacman = { x: 10 * tileSize, y: 15 * tileSize, dir: null, nextDir: null, speed: 2 }; // Pac-Man's pixel position, speed, and intended next direction
        let ghosts = [ // Updated ghosts with colors and new starting positions
            { x: 9 * tileSize, y: 8 * tileSize, color: 'red', speed: GHOST_NORMAL_SPEED, dir: null },
            { x: 9 * tileSize, y: 9 * tileSize, color: 'pink', speed: GHOST_NORMAL_SPEED, dir: null },
            { x: 10 * tileSize, y: 9 * tileSize, color: 'cyan', speed: GHOST_NORMAL_SPEED, dir: null },
            { x: 10 * tileSize, y: 8 * tileSize, color: 'orange', speed: GHOST_NORMAL_SPEED, dir: null }
        ];
        let score = 0;
        let highScore = parseInt(localStorage.getItem('pacmanHighScore')) || 0; // Load high score or default to 0
        
        // Audio Management
        const audioElements = {
            gameStart: document.getElementById('gameStart'),
            chomp: document.getElementById('chomp'),
            death: document.getElementById('death'),
            ghostEaten: document.getElementById('ghostEaten'),
            powerPellet: document.getElementById('powerPellet'),
            levelComplete: document.getElementById('levelComplete'),
            backgroundMusic: document.getElementById('backgroundMusic')
        };

        // Function to play a sound
        function playSound(soundName) {
            const sound = audioElements[soundName];
            if (sound) {
                sound.currentTime = 0; // Reset to start
                sound.play().catch(error => console.log('Audio play failed:', error));
            }
        }

        // Function to stop a sound
        function stopSound(soundName) {
            const sound = audioElements[soundName];
            if (sound) {
                sound.pause();
                sound.currentTime = 0;
            }
        }

        // Function to toggle background music
        function toggleBackgroundMusic() {
            if (audioElements.backgroundMusic.paused) {
                audioElements.backgroundMusic.play().catch(error => console.log('Background music play failed:', error));
            } else {
                audioElements.backgroundMusic.pause();
            }
        }

        // Add keyboard shortcut for music (M key)
        document.addEventListener('keydown', e => {
            if (e.key.toLowerCase() === 'm') {
                toggleBackgroundMusic();
            }
        });

        function drawMaze() {
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    } else if (maze[y][x] === 0) {
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize/2, y * tileSize + tileSize/2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (maze[y][x] === 4 && energizerVisible) {
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize/2, y * tileSize + tileSize/2, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw the white line for the ghost house gate
            const gateLineWidth = 3; // Define line width for clarity and reuse
            const halfGateLineWidth = gateLineWidth / 2; // Corrected: This should be half of the actual line width
            
            // Calculate Y position so the top of the line is flush with the top of the side walls.
            // The side walls' top edge is at y = 8 * tileSize.
            // The line's path is its center. To make its top edge align with 8*tileSize,
            // the center of the path needs to be at (8*tileSize) + halfGateLineWidth.
            const gateYPosition = (8 * tileSize) + halfGateLineWidth;
            
            // Calculate X positions so the ends of the line are flush with the inner edges of side walls
            // The path starts/ends need to be inset/outset by half the line width.
            const gateStartX = (9 * tileSize) + halfGateLineWidth;
            const gateEndX = (12 * tileSize) - halfGateLineWidth;

            ctx.beginPath();
            ctx.moveTo(gateStartX, gateYPosition);
            ctx.lineTo(gateEndX, gateYPosition);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = gateLineWidth;
            ctx.stroke();
        }
        
        function drawPacman() {
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            
            // Define mouth angles based on direction and mouth state
            let startAngle, endAngle;
            const currentDir = pacman.dir || 'right'; // Default to right if no direction yet
            
            if (mouthOpen) {
                // Wide open mouth
                if (currentDir === 'right') {
                    startAngle = 0.2 * Math.PI;
                    endAngle = 1.8 * Math.PI;
                } else if (currentDir === 'left') {
                    startAngle = 1.2 * Math.PI;
                    endAngle = 0.8 * Math.PI; 
                } else if (currentDir === 'up') {
                    startAngle = 1.7 * Math.PI;
                    endAngle = 1.3 * Math.PI;
                } else if (currentDir === 'down') {
                    startAngle = 0.7 * Math.PI;
                    endAngle = 0.3 * Math.PI;
                }
            } else {
                // Almost closed mouth
                if (currentDir === 'right') {
                    startAngle = 0.05 * Math.PI;
                    endAngle = 1.95 * Math.PI;
                } else if (currentDir === 'left') {
                    startAngle = 1.05 * Math.PI;
                    endAngle = 0.95 * Math.PI; 
                } else if (currentDir === 'up') {
                    startAngle = 1.55 * Math.PI;
                    endAngle = 1.45 * Math.PI;
                } else if (currentDir === 'down') {
                    startAngle = 0.55 * Math.PI;
                    endAngle = 0.45 * Math.PI;
                }
            }

            ctx.arc(pacman.x + tileSize/2, pacman.y + tileSize/2, tileSize/2, startAngle, endAngle);
            ctx.lineTo(pacman.x + tileSize/2, pacman.y + tileSize/2);
            ctx.fill();
        }
        
        function drawPacmanDeathAnimation() {
            ctx.fillStyle = 'yellow';
            ctx.beginPath();

            const centerX = pacman.x + tileSize / 2;
            const centerY = pacman.y + tileSize / 2;
            
            // Animation: Pac-Man shrinks
            // Progress: 0 (start) to 1 (end)
            const progress = pacmanDeathAnimationProgress;

            let currentRadius = tileSize / 2;
            // Mouth is considered closed (full circle) for simplicity during death
            let startAngle = 0; 
            let endAngle = Math.PI * 2; 
            
            // Shrinking part
            currentRadius *= (1 - progress);
            
            if (currentRadius > 0.1) { // Draw until very small
                ctx.arc(centerX, centerY, currentRadius, startAngle, endAngle);
                // ctx.lineTo(centerX, centerY); // Not strictly necessary for arc if it's a full circle and filled
                ctx.fill();
            }
        }
        
        function drawGhosts() {
            ghosts.forEach(ghost => {
                let ghostFillStyle = ghost.color; // Normal color by default
                let isScaredLooking = false; // Flag for scared appearance

                if (energizerActive && ghost.isScared && !ghost.isEyes) {
                    isScaredLooking = true; // Mark as scared for mouth drawing logic
                    // Flashing logic for scared ghosts
                    if (Date.now() - energizerTimer > ENERGIZER_FLASH_START_TIME) {
                        if (ghostFlashOn) {
                            ghostFillStyle = 'white'; // Flash white
                        } else {
                            ghostFillStyle = 'blue'; // Scared blue
                        }
                    } else {
                        ghostFillStyle = 'blue'; // Solid blue before flashing period
                    }
                } else if (ghost.isEyes) {
                    ghostFillStyle = 'white'; // Eyes only when eaten
                }
                ctx.fillStyle = ghostFillStyle;

                const bodyHeight = tileSize * 0.6;
                const headRadius = tileSize / 2;

                if (ghost.isEyes) {
                    // Draw only eyes
                    const eyeRadius = tileSize / 8;
                    const eyeOffsetX = tileSize / 4;
                    // Eyes should be centered on the ghost's pixel position
                    const eyeBaseY = ghost.y + tileSize / 2 - eyeRadius;


                    // Left eye
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(ghost.x + eyeOffsetX, eyeBaseY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(ghost.x + eyeOffsetX, eyeBaseY, eyeRadius / 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Right eye
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(ghost.x + tileSize - eyeOffsetX, eyeBaseY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(ghost.x + tileSize - eyeOffsetX, eyeBaseY, eyeRadius / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Ghost body/head drawing logic using ghost.x and ghost.y directly
                    const gx = ghost.x;
                    const gy = ghost.y;
                    const R = tileSize / 2; // headRadius
                    const bodyOverallHeight = tileSize * 0.6; 
                    const bodyTopY = gy + R; 

                    const waveEffectHeight = bodyOverallHeight / 3;
                    const upperStraightSkirtHeight = bodyOverallHeight - waveEffectHeight;

                    const wavePeakY = bodyTopY + upperStraightSkirtHeight; 
                    const waveValleyY = bodyTopY + bodyOverallHeight;      

                    ctx.beginPath();
                    ctx.arc(gx + R, bodyTopY, R, Math.PI, 0);
                    ctx.lineTo(gx + tileSize, wavePeakY);
                    ctx.lineTo(gx + (5 * tileSize / 6), waveValleyY); 
                    ctx.lineTo(gx + (2 * tileSize / 3), wavePeakY);   
                    ctx.lineTo(gx + (tileSize / 2), waveValleyY);     
                    ctx.lineTo(gx + (tileSize / 3), wavePeakY);       
                    ctx.lineTo(gx + (tileSize / 6), waveValleyY);     
                    ctx.lineTo(gx + 0, wavePeakY);                    
                    ctx.lineTo(gx + 0, bodyTopY);
                    ctx.closePath();
                    ctx.fill(); 

                    // Draw eyes (and mouth if scared)
                    const eyeRadius = tileSize / 8;
                    const eyeOffsetX = tileSize / 4;
                    const eyeBaseY = ghost.y + tileSize / 2.5; 
                    
                    // Common white part for both eyes - must be drawn for both normal and scared
                    ctx.fillStyle = 'white';
                    // Left eye (white part)
                    ctx.beginPath();
                    ctx.arc(ghost.x + eyeOffsetX, eyeBaseY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Right eye (white part)
                    ctx.beginPath();
                    ctx.arc(ghost.x + tileSize - eyeOffsetX, eyeBaseY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();

                    if (isScaredLooking) {
                        // Draw scared mouth (no pupils)
                        ctx.strokeStyle = 'white'; 
                        ctx.lineWidth = 1; // Sharp pixel line
                        ctx.beginPath();
                        const mouthWidth = tileSize * 0.5; // Width of the mouth
                        const mouthSegments = 4; // Number of segments for the W-shape
                        const mouthSegmentWidth = mouthWidth / mouthSegments;
                        const mouthAmplitude = tileSize / 7; // Depth of the jags
                        const mouthYLine = eyeBaseY + eyeRadius + tileSize / 8; // Y position of the mouth's top line

                        const mouthStartX = ghost.x + (tileSize - mouthWidth) / 2; // Center the mouth horizontally

                        ctx.moveTo(mouthStartX, mouthYLine);
                        ctx.lineTo(mouthStartX + mouthSegmentWidth, mouthYLine + mouthAmplitude); // Jag down
                        ctx.lineTo(mouthStartX + 2 * mouthSegmentWidth, mouthYLine); // Jag up to center line
                        ctx.lineTo(mouthStartX + 3 * mouthSegmentWidth, mouthYLine + mouthAmplitude); // Jag down
                        ctx.lineTo(mouthStartX + 4 * mouthSegmentWidth, mouthYLine); // Jag up to end
                        ctx.stroke();
                    } else {
                        // Draw normal pupils
                        let pupilOffsetX = 0;
                        let pupilOffsetY = 0;
                        const currentGhostDir = ghost.dir || 'right'; // Default to right if no direction

                        if (currentGhostDir === 'right') {
                            pupilOffsetX = eyeRadius / 2;
                        } else if (currentGhostDir === 'left') {
                            pupilOffsetX = -eyeRadius / 2;
                        } else if (currentGhostDir === 'up') {
                            pupilOffsetY = -eyeRadius / 2;
                        } else if (currentGhostDir === 'down') {
                            pupilOffsetY = eyeRadius / 2;
                        }

                        ctx.fillStyle = 'black';
                        // Left pupil
                        ctx.beginPath();
                        ctx.arc(ghost.x + eyeOffsetX + pupilOffsetX, eyeBaseY + pupilOffsetY, eyeRadius / 2, 0, Math.PI * 2);
                        ctx.fill();

                        // Right pupil
                        ctx.beginPath();
                        ctx.arc(ghost.x + tileSize - eyeOffsetX + pupilOffsetX, eyeBaseY + pupilOffsetY, eyeRadius / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }
        
        function drawMiniPacman(ctx, x, y) {
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(x, y, 6, 1.2 * Math.PI, 0.8 * Math.PI);
            ctx.lineTo(x, y);
            ctx.fill();
        }

        function updateLivesDisplay() {
            const livesDisplay = document.getElementById('livesDisplay');
            livesDisplay.innerHTML = '';
            for (let i = 0; i < extraLives; i++) { // Display extraLives icons
                const canvas = document.createElement('canvas');
                canvas.className = 'lifeIcon';
                canvas.width = 15;
                canvas.height = 15;
                const miniCtx = canvas.getContext('2d');
                drawMiniPacman(miniCtx, 7, 7);
                livesDisplay.appendChild(canvas);
            }
        }
        
        function update() {
            if (pacmanDeathAnimationActive) {
                pacmanDeathAnimationProgress += (20 / PACMAN_DEATH_ANIMATION_DURATION_MS); // 20ms is game loop interval

                if (pacmanDeathAnimationProgress >= 1) {
                    pacmanDeathAnimationActive = false;
                    pacmanDeathAnimationProgress = 0;

                    // Logic that was previously in the collision detection for Pac-Man death
                    extraLives--;
                    consecutiveGhostsEaten = 0; // Reset counter if Pac-Man dies

                    if (extraLives >= 0) {
                        pacman = { x: 10 * tileSize, y: 15 * tileSize, dir: null, nextDir: null, speed: 2 };
                        ghosts.forEach(g => {
                            if (g.color === 'red') { g.x = 9 * tileSize; g.y = 8 * tileSize; }
                            else if (g.color === 'pink') { g.x = 9 * tileSize; g.y = 9 * tileSize; }
                            else if (g.color === 'cyan') { g.x = 10 * tileSize; g.y = 9 * tileSize; }
                            else if (g.color === 'orange') { g.x = 10 * tileSize; g.y = 8 * tileSize; }
                            g.isEyes = false;
                            g.isScared = false;
                            g.dir = null;
                            g.currentMove = null;
                            g.speed = GHOST_NORMAL_SPEED;
                        });
                        updateLivesDisplay();
                    } else {
                        window.gameOver = true;
                        localStorage.setItem('pacmanHighScore', highScore);
                        document.getElementById('insertCreditArea').style.display = 'flex';
                    }
                }
                return; // Stop further game updates during death animation, or if it just finished
            }

            if (window.gameOver || levelClearPauseActive) return;

            // Check for Energizer Expiration
            if (energizerActive && (Date.now() - energizerTimer > energizerDuration)) {
                energizerActive = false;
                energizerTimer = 0; // Reset timer
                consecutiveGhostsEaten = 0; // Reset counter when energizer wears off
                ghostFlashOn = false; // Reset flash state
                ghosts.forEach(ghost => {
                    ghost.isScared = false; // Revert ghosts to normal (not scared)
                    ghost.speed = GHOST_NORMAL_SPEED; // Reset speed
                    // Note: isEyes state is handled separately when ghosts are eaten and return home
                });
            }

            // Mouth animation
            mouthFrameCounter++;
            if (mouthFrameCounter >= MOUTH_ANIMATION_FRAMES) {
                mouthOpen = !mouthOpen;
                mouthFrameCounter = 0;
            }

            // Energizer Blinking Logic
            const currentTime = Date.now();
            if (currentTime - energizerBlinkTimer > ENERGIZER_BLINK_INTERVAL) {
                energizerVisible = !energizerVisible;
                energizerBlinkTimer = currentTime;
            }

            // Ghost Flashing Logic (when energizer is active and about to end)
            if (energizerActive && Date.now() - energizerTimer > ENERGIZER_FLASH_START_TIME) {
                if (currentTime - lastGhostFlashTime > GHOST_FLASH_INTERVAL) {
                    ghostFlashOn = !ghostFlashOn;
                    lastGhostFlashTime = currentTime;
                }
            } else if (!energizerActive) {
                ghostFlashOn = false; // Ensure flash is off if energizer is not active
            }

            // Remove expired score displays
            temporaryScoreDisplays = temporaryScoreDisplays.filter(
                item => Date.now() - item.timestamp < SCORE_DISPLAY_DURATION
            );

            const mazeWidthPx = maze[0].length * tileSize;
            const mazeHeightPx = maze.length * tileSize;
            const TILE_CENTER_OFFSET = tileSize / 2;

            // --- PAC-MAN MOVEMENT --- 
            let currentPacmanTileX = Math.floor(pacman.x / tileSize);
            let currentPacmanTileY = Math.floor(pacman.y / tileSize);
            let pacmanCenterX = pacman.x + TILE_CENTER_OFFSET;
            let pacmanCenterY = pacman.y + TILE_CENTER_OFFSET;

            // Check if Pac-Man is aligned with the grid for turning
            const isAlignedX = pacman.x % tileSize === 0;
            const isAlignedY = pacman.y % tileSize === 0;

            // Try to change direction if a new direction is queued and Pac-Man is aligned
            if (pacman.nextDir && isAlignedX && isAlignedY) {
                let testPixelX = pacman.x;
                let testPixelY = pacman.y;
                let testTileX = currentPacmanTileX;
                let testTileY = currentPacmanTileY;

                if (pacman.nextDir === 'left') { testPixelX -= pacman.speed; testTileX--; }
                else if (pacman.nextDir === 'right') { testPixelX += pacman.speed; testTileX++; }
                else if (pacman.nextDir === 'up') { testPixelY -= pacman.speed; testTileY--; }
                else if (pacman.nextDir === 'down') { testPixelY += pacman.speed; testTileY++; }

                if (testTileX >= 0 && testTileX < maze[0].length && testTileY >= 0 && testTileY < maze.length &&
                    maze[testTileY][testTileX] !== 1 && maze[testTileY][testTileX] !== 3) {
                    pacman.dir = pacman.nextDir;
                    pacman.nextDir = null;
                }
            }

            let intendedPixelX = pacman.x;
            let intendedPixelY = pacman.y;

            if (pacman.dir === 'left') intendedPixelX -= pacman.speed;
            else if (pacman.dir === 'right') intendedPixelX += pacman.speed;
            else if (pacman.dir === 'up') intendedPixelY -= pacman.speed;
            else if (pacman.dir === 'down') intendedPixelY += pacman.speed;
            
            // Determine the tile Pac-Man is trying to move into
            let targetTileX = currentPacmanTileX;
            let targetTileY = currentPacmanTileY;

            if (pacman.dir === 'left') targetTileX = Math.floor(intendedPixelX / tileSize);
            else if (pacman.dir === 'right') targetTileX = Math.ceil((intendedPixelX) / tileSize); // Use intendedPixelX, not pacman.x
            else if (pacman.dir === 'up') targetTileY = Math.floor(intendedPixelY / tileSize);
            else if (pacman.dir === 'down') targetTileY = Math.ceil((intendedPixelY) / tileSize); // Use intendedPixelY, not pacman.y

            // Tunnel Logic - applied before wall collision for movement
            const tunnelYTile = 9;
            const isInTunnelCorridor = Math.floor(pacmanCenterY / tileSize) === tunnelYTile;

            if (isInTunnelCorridor && pacman.dir === 'left' && pacmanCenterX - pacman.speed <= TILE_CENTER_OFFSET) { // Moving left into tunnel exit
                 if (currentPacmanTileX === 0) { // Check if at the leftmost tile
                    pacman.x = mazeWidthPx - tileSize; // Emerge from right, position aligned
                    intendedPixelX = pacman.x; // Update intended for further logic if any
                 }
            } else if (isInTunnelCorridor && pacman.dir === 'right' && pacmanCenterX + pacman.speed >= mazeWidthPx - TILE_CENTER_OFFSET) { // Moving right into tunnel exit
                if (currentPacmanTileX === maze[0].length -1) { // Check if at the rightmost tile
                    pacman.x = 0; // Emerge from left, position aligned
                    intendedPixelX = pacman.x; // Update intended for further logic if any
                }
            }

            // Wall Collision and Movement
            if (pacman.dir) {
                let canMove = true;
                // Recalculate current tile based on potentially updated pacman.x from tunnel
                currentPacmanTileX = Math.floor(pacman.x / tileSize);
                currentPacmanTileY = Math.floor(pacman.y / tileSize);

                if (pacman.dir === 'left') {
                    if (intendedPixelX < 0 || (isAlignedY && maze[currentPacmanTileY][currentPacmanTileX - 1] === 1 && intendedPixelX < currentPacmanTileX * tileSize)) {
                        intendedPixelX = currentPacmanTileX * tileSize;
                        if (isAlignedY && pacman.nextDir && (pacman.nextDir === 'up' || pacman.nextDir === 'down')) { /* allow turn attempt next cycle */ } else { /* pacman.dir = null; */ }
                    }
                } else if (pacman.dir === 'right') {
                    if (intendedPixelX + tileSize > mazeWidthPx || (isAlignedY && maze[currentPacmanTileY][currentPacmanTileX + 1] === 1 && intendedPixelX + tileSize > (currentPacmanTileX + 1) * tileSize)) {
                        intendedPixelX = currentPacmanTileX * tileSize;
                        if (isAlignedY && pacman.nextDir && (pacman.nextDir === 'up' || pacman.nextDir === 'down')) { /* allow turn attempt next cycle */ } else { /* pacman.dir = null; */ }
                    }
                } else if (pacman.dir === 'up') {
                    if (intendedPixelY < 0 || (isAlignedX && maze[currentPacmanTileY - 1][currentPacmanTileX] === 1 && intendedPixelY < currentPacmanTileY * tileSize)) {
                        intendedPixelY = currentPacmanTileY * tileSize;
                        if (isAlignedX && pacman.nextDir && (pacman.nextDir === 'left' || pacman.nextDir === 'right')) { /* allow turn attempt next cycle */ } else { /* pacman.dir = null; */ }
                    }
                } else if (pacman.dir === 'down') {
                    if (intendedPixelY + tileSize > mazeHeightPx || (isAlignedX && maze[currentPacmanTileY + 1][currentPacmanTileX] === 1 && intendedPixelY + tileSize > (currentPacmanTileY + 1) * tileSize)) {
                        intendedPixelY = currentPacmanTileY * tileSize;
                        if (isAlignedX && pacman.nextDir && (pacman.nextDir === 'left' || pacman.nextDir === 'right')) { /* allow turn attempt next cycle */ } else { /* pacman.dir = null; */ }
                    }
                }
                
                // Check if the CENTER of pacman in its INTENDED position would be in a wall tile
                let intendedCenterX = intendedPixelX + TILE_CENTER_OFFSET;
                let intendedCenterY = intendedPixelY + TILE_CENTER_OFFSET;
                let intendedNextTileX = Math.floor(intendedCenterX / tileSize);
                let intendedNextTileY = Math.floor(intendedCenterY / tileSize);
                
                if (pacman.dir === 'left' || pacman.dir === 'right') {
                     if (maze[intendedNextTileY]?.[intendedNextTileX] === 1 || maze[intendedNextTileY]?.[intendedNextTileX] === 3) {
                        pacman.x = (pacman.dir === 'left' ? (intendedNextTileX + 1) * tileSize : intendedNextTileX * tileSize - tileSize);
                        // pacman.dir = null; // Stop Pacman
                    } else {
                        pacman.x = intendedPixelX;
                    }
                } else if (pacman.dir === 'up' || pacman.dir === 'down') {
                    if (maze[intendedNextTileY]?.[intendedNextTileX] === 1 || maze[intendedNextTileY]?.[intendedNextTileX] === 3) {
                        pacman.y = (pacman.dir === 'up' ? (intendedNextTileY + 1) * tileSize : intendedNextTileY * tileSize - tileSize);
                        // pacman.dir = null; // Stop Pacman
                    } else {
                        pacman.y = intendedPixelY;
                    }
                }

            }

            // Clamp Pac-Man's position to be within canvas boundaries (after tunnel and movement)
            pacman.x = Math.max(0, Math.min(pacman.x, mazeWidthPx - tileSize));
            pacman.y = Math.max(0, Math.min(pacman.y, mazeHeightPx - tileSize));

            // --- DOT EATING --- (Remains largely the same, uses center of Pac-Man)
            const eatingTileX = Math.floor((pacman.x + TILE_CENTER_OFFSET) / tileSize);
            const eatingTileY = Math.floor((pacman.y + TILE_CENTER_OFFSET) / tileSize);

            if (eatingTileX >= 0 && eatingTileX < maze[0].length &&
                eatingTileY >= 0 && eatingTileY < maze.length) {
                if (maze[eatingTileY][eatingTileX] === 0) { // Dot
                    maze[eatingTileY][eatingTileX] = 2; // Mark as eaten
                    score += 10;
                    playSound('chomp');
                } else if (maze[eatingTileY][eatingTileX] === 4) { // Energizer
                    maze[eatingTileY][eatingTileX] = 2; // Mark as eaten
                    score += 50;
                    playSound('powerPellet');
                    energizerActive = true;
                    energizerTimer = Date.now();
                    consecutiveGhostsEaten = 0; // Reset counter when a new energizer is eaten
                    ghosts.forEach(ghost => {
                        if (!ghost.isEyes) { // Only make non-eaten ghosts scared
                            ghost.isScared = true;
                            ghost.speed = GHOST_SCARED_SPEED; // Slow down when scared
                        }
                    });
                }
                // Check if all dots eaten after eating one
                if (checkAllDotsEaten()) {
                    levelClearPauseActive = true;
                    playSound('levelComplete');
                    setTimeout(() => {
                        prepareNextLevel();
                    }, 3000); // 3-second pause
                }
            }

            ghosts.forEach(ghost => {
                const ghostTileX = Math.round(ghost.x / tileSize);
                const ghostTileY = Math.round(ghost.y / tileSize);
                const pacmanCurrentTileX = Math.round(pacman.x / tileSize); // Pacman's current tile
                const pacmanCurrentTileY = Math.round(pacman.y / tileSize); // Pacman's current tile

                if (ghost.isEyes) {
                    const homeTargetX = 10 * tileSize; // Ghost home in pixels
                    const homeTargetY = 9 * tileSize;  // Ghost home in pixels
                    
                    let dx = 0, dy = 0;
                    if (ghost.x < homeTargetX) dx = ghost.speed;
                    else if (ghost.x > homeTargetX) dx = -ghost.speed;
                    if (ghost.y < homeTargetY) dy = ghost.speed;
                    else if (ghost.y > homeTargetY) dy = -ghost.speed;

                    // More precise check for reaching home
                    if (Math.abs(ghost.x - homeTargetX) < ghost.speed && Math.abs(ghost.y - homeTargetY) < ghost.speed) {
                        ghost.x = homeTargetX;
                        ghost.y = homeTargetY;
                        ghost.isEyes = false;
                        ghost.isScared = false; // Ensure respawned ghost is not scared
                        ghost.dir = null; // Reset direction
                        ghost.speed = GHOST_NORMAL_SPEED; // Ensure speed is reset
                    } else {
                        // Move ghost eyes
                        ghost.x += dx;
                        ghost.y += dy;
                        // Set direction for pupil movement
                        if (dx > 0) ghost.dir = 'right'; else if (dx < 0) ghost.dir = 'left';
                        else if (dy > 0) ghost.dir = 'down'; else if (dy < 0) ghost.dir = 'up'; else ghost.dir = null;
                    }
                } else {
                    // Ghost AI movement - needs to be tile-aligned for turning
                    if ((ghost.x % tileSize < ghost.speed && ghost.x % tileSize > -ghost.speed) && 
                        (ghost.y % tileSize < ghost.speed && ghost.y % tileSize > -ghost.speed)) { // If aligned to grid
                        
                        ghost.x = Math.round(ghost.x / tileSize) * tileSize; // Snap to grid
                        ghost.y = Math.round(ghost.y / tileSize) * tileSize;

                        const possibleMoves = [];
                        const currentGhostTileX = Math.round(ghost.x / tileSize);
                        const currentGhostTileY = Math.round(ghost.y / tileSize);

                        // Check potential moves (Up, Down, Left, Right)
                        // Up
                        if (currentGhostTileY > 0 && maze[currentGhostTileY - 1][currentGhostTileX] !== 1 && ghost.dir !== 'down') 
                            possibleMoves.push({dx:0, dy:-ghost.speed, dir: 'up', tileX: currentGhostTileX, tileY: currentGhostTileY - 1});
                        // Down
                        if (currentGhostTileY < maze.length - 1 && maze[currentGhostTileY + 1][currentGhostTileX] !== 1 && ghost.dir !== 'up') 
                            possibleMoves.push({dx:0, dy:ghost.speed, dir: 'down', tileX: currentGhostTileX, tileY: currentGhostTileY + 1});
                        // Left
                        if (currentGhostTileX > 0 && maze[currentGhostTileY][currentGhostTileX - 1] !== 1 && ghost.dir !== 'right') 
                            possibleMoves.push({dx:-ghost.speed, dy:0, dir: 'left', tileX: currentGhostTileX - 1, tileY: currentGhostTileY});
                        // Right
                        if (currentGhostTileX < maze[0].length - 1 && maze[currentGhostTileY][currentGhostTileX + 1] !== 1 && ghost.dir !== 'left') 
                            possibleMoves.push({dx:ghost.speed, dy:0, dir: 'right', tileX: currentGhostTileX + 1, tileY: currentGhostTileY});
                        
                        if (possibleMoves.length > 0) {
                            let chosenMove;
                            
                            // Get target for this ghost
                            const target = getGhostTarget(ghost, pacman.x, pacman.y, pacman.dir);
                            
                            if (ghost.isScared || ghost.color === 'orange' || !target) {
                                // Random movement for scared ghosts, Clyde, or if no target
                                chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                            } else {
                                // For other ghosts, move toward their target
                                // Calculate distance to target for each possible move
                                possibleMoves.forEach(move => {
                                    move.distance = Math.sqrt(
                                        Math.pow(move.tileX - target.x, 2) + 
                                        Math.pow(move.tileY - target.y, 2)
                                    );
                                });
                                
                                // Sort by distance (closest first)
                                possibleMoves.sort((a, b) => a.distance - b.distance);
                                
                                // Choose the move that gets closest to target
                                chosenMove = possibleMoves[0];
                            }
                            
                            ghost.currentMove = chosenMove; // Store the chosen move
                            ghost.dir = chosenMove.dir; // Update ghost's direction property
                        } else {
                            // If no moves, try to reverse (e.g. dead end)
                            if (ghost.dir === 'up') ghost.currentMove = {dx:0, dy:ghost.speed, dir: 'down'};
                            else if (ghost.dir === 'down') ghost.currentMove = {dx:0, dy:-ghost.speed, dir: 'up'};
                            else if (ghost.dir === 'left') ghost.currentMove = {dx:ghost.speed, dy:0, dir: 'right'};
                            else if (ghost.dir === 'right') ghost.currentMove = {dx:-ghost.speed, dy:0, dir: 'left'};
                            if (ghost.currentMove) ghost.dir = ghost.currentMove.dir;
                        }
                    }
                    
                    // Apply movement based on stored move
                    if (ghost.currentMove) {
                        ghost.x += ghost.currentMove.dx;
                        ghost.y += ghost.currentMove.dy;
                    }

                    // Add tunnel teleportation for ghosts
                    const ghostCenterX = ghost.x + tileSize/2;
                    const ghostCenterY = ghost.y + tileSize/2;
                    const isGhostInTunnelCorridor = Math.floor(ghostCenterY / tileSize) === tunnelYTile;
                    
                    if (isGhostInTunnelCorridor) {
                        if (ghost.dir === 'left' && ghost.x < 0) {
                            ghost.x = mazeWidthPx - tileSize; // Teleport to right side
                        } else if (ghost.dir === 'right' && ghost.x > mazeWidthPx - tileSize) {
                            ghost.x = 0; // Teleport to left side
                        }
                    }
                }

                // Collision with Pac-Man (pixel-based, using a small tolerance)
                const collisionThreshold = tileSize * 0.75; // If centers are within 3/4 of a tile
                if (Math.abs(pacman.x - ghost.x) < collisionThreshold && Math.abs(pacman.y - ghost.y) < collisionThreshold && !window.gameOver) {
                    if (energizerActive && ghost.isScared && !ghost.isEyes) {
                        ghost.isEyes = true;
                        ghost.isScared = false;
                        consecutiveGhostsEaten++;
                        playSound('ghostEaten');
                        let bonusPoints = 0;
                        switch (consecutiveGhostsEaten) {
                            case 1: bonusPoints = 200; break;
                            case 2: bonusPoints = 400; break;
                            case 3: bonusPoints = 800; break;
                            case 4: bonusPoints = 1600; break;
                            default: bonusPoints = 1600; // Or some other value for 5th+ ghost
                        }
                        score += bonusPoints;
                        // Add score display
                        temporaryScoreDisplays.push({
                            value: bonusPoints,
                            x: ghost.x + tileSize / 2, // Center on ghost
                            y: ghost.y + tileSize / 2,
                            timestamp: Date.now()
                        });
                        ghost.speed = GHOST_NORMAL_SPEED; // Eyes move at normal speed
                        // No need to move ghost to home here, eye logic will handle it
                    } else if (!ghost.isEyes && !pacmanDeathAnimationActive) {
                        playSound('death');
                        pacmanDeathAnimationActive = true;
                        pacmanDeathAnimationProgress = 0;
                        // Life decrement and position resets are now handled at the end of the animation
                    }
                }
            });

            // Update high score if current score is higher
            if (score > highScore) {
                highScore = score;
            }

            // Check for extra life
            if (score >= scoreForNextExtraLife) {
                extraLives++;
                scoreForNextExtraLife += 10000; // Set the next target
                updateLivesDisplay();
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            
            if (pacmanDeathAnimationActive) {
                drawPacmanDeathAnimation();
            } else if (!levelClearPauseActive && !window.gameOver) {
                // Only draw normal Pac-Man if not in death animation,
                // not clearing level, and game is not over.
                drawPacman();
            }
            
            drawGhosts(); // Ghosts are drawn regardless of Pac-Man's state

            // Draw temporary score displays
            temporaryScoreDisplays.forEach(display => {
                ctx.fillStyle = '#00FFFF'; // Cyan color like the image
                ctx.font = '12px monospace'; // Adjust size as needed
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(display.value.toString(), display.x, display.y);
            });

            // Update the score in the dedicated HTML element
            document.getElementById('scoreValue').textContent = score;
            document.getElementById('highScoreValueDisplay').textContent = highScore; // Display high score

            if (levelClearPauseActive) {
                ctx.fillStyle = 'yellow';
                ctx.font = '30px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('LEVEL CLEAR!', baseWidth / 2, baseHeight / 2);
            } else if (window.gameOver && !pacmanDeathAnimationActive) {
                // Show GAME OVER only if not in death animation and game is actually over
                ctx.fillStyle = 'red';
                ctx.font = '30px monospace'; // Using monospace to match existing style
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle'; // For better vertical alignment
                const yGameOverPosition = baseHeight / 2; // Vertically centered on screen
                ctx.fillText('GAME OVER', baseWidth / 2, yGameOverPosition);
            }
        }
        
        function resetGame() {
            playSound('gameStart');
            // Save high score before resetting anything else
            localStorage.setItem('pacmanHighScore', highScore);

            // Reset maze (restore all dots)
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    maze[y][x] = originalMaze[y][x];
                }
            }
            // Add power pellets
            maze[2][1] = 4;
            maze[2][19] = 4;
            maze[15][1] = 4;
            maze[15][19] = 4;
            
            // Reset Pac-Man
            pacman = { x: 10 * tileSize, y: 15 * tileSize, dir: null, nextDir: null, speed: 2 };
            
            // Reset ghosts
            ghosts = [
                { x: 9 * tileSize, y: 8 * tileSize, color: 'red', isEyes: false, isScared: false, dir: null, speed: GHOST_NORMAL_SPEED, currentMove: null },
                { x: 9 * tileSize, y: 9 * tileSize, color: 'pink', isEyes: false, isScared: false, dir: null, speed: GHOST_NORMAL_SPEED, currentMove: null },
                { x: 10 * tileSize, y: 9 * tileSize, color: 'cyan', isEyes: false, isScared: false, dir: null, speed: GHOST_NORMAL_SPEED, currentMove: null },
                { x: 10 * tileSize, y: 8 * tileSize, color: 'orange', isEyes: false, isScared: false, dir: null, speed: GHOST_NORMAL_SPEED, currentMove: null }
            ];
            
            // Reset score
            score = 0;
            
            // Reset lives
            extraLives = 3; // Reset to initial number of extra lives
            updateLivesDisplay();
            
            // Reset game state
            window.gameOver = false;
            energizerActive = false;
            energizerTimer = 0;
            consecutiveGhostsEaten = 0;
            ghostFlashOn = false; // Reset flash state on game reset
            mouthOpen = true; // Reset mouth state
            mouthFrameCounter = 0; // Reset mouth animation counter
            document.getElementById('insertCreditArea').style.display = 'none'; // Hide insert credit text
            levelClearPauseActive = false; // Ensure this is reset too
            scoreForNextExtraLife = 10000; // Reset extra life score target when starting a new level
            
            pacmanDeathAnimationActive = false; // Reset death animation state
            pacmanDeathAnimationProgress = 0;   // Reset death animation progress

            // If the game loop was stopped, restart it
            if (!gameLoopInterval) {
                gameLoopInterval = setInterval(() => { update(); draw(); }, 20);
            }
            
            // Update display
            draw();
        }
        
        function checkAllDotsEaten() {
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 0 || maze[y][x] === 4) { // Check for uneaten dots or energizers
                        return false; // Found an uneaten item
                    }
                }
            }
            return true; // All items eaten
        }

        function prepareNextLevel() {
            // Reset maze (restore all dots)
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    maze[y][x] = originalMaze[y][x];
                }
            }
            // Add power pellets
            maze[2][1] = 4;
            maze[2][19] = 4;
            maze[15][1] = 4;
            maze[15][19] = 4;
            
            // Reset Pac-Man's position and state
            pacman = { x: 10 * tileSize, y: 15 * tileSize, dir: null, nextDir: null, speed: 2 };
            
            // Reset ghosts' positions and states
            ghosts.forEach(g => {
                if (g.color === 'red') { g.x = 9 * tileSize; g.y = 8 * tileSize; }
                else if (g.color === 'pink') { g.x = 9 * tileSize; g.y = 9 * tileSize; }
                else if (g.color === 'cyan') { g.x = 10 * tileSize; g.y = 9 * tileSize; }
                else if (g.color === 'orange') { g.x = 10 * tileSize; g.y = 8 * tileSize; }
                g.isEyes = false;
                g.isScared = false;
                g.dir = null;
                g.currentMove = null;
                g.speed = GHOST_NORMAL_SPEED;
            });
            
            // Reset relevant game state variables (but not score or lives)
            energizerActive = false;
            energizerTimer = 0;
            consecutiveGhostsEaten = 0;
            ghostFlashOn = false;
            mouthOpen = true;
            mouthFrameCounter = 0;
            levelClearPauseActive = false; // End the pause
            
            pacmanDeathAnimationActive = false; // Reset death animation state
            pacmanDeathAnimationProgress = 0;   // Reset death animation progress

            // Ensure game loop is running (shouldn't be necessary if pause logic is correct)
            if (!gameLoopInterval && !window.gameOver) { // Only restart if not game over
                 gameLoopInterval = setInterval(() => { update(); draw(); }, 20);
            }
            
            updateLivesDisplay(); // Lives are preserved
            draw(); // Redraw the new level
        }
        
        // Game controls
        document.addEventListener('keydown', e => {
            let newNextDir = null;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') newNextDir = 'right';
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') newNextDir = 'left';
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') newNextDir = 'down';
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') newNextDir = 'up';

            if (newNextDir) {
                pacman.nextDir = newNextDir; // Queue the direction
            }
            
            // Check for '1' to restart the game when game over
            if (e.key === '1' && window.gameOver) {
                resetGame();
            }
        });
        
        let gameLoopInterval = setInterval(() => { update(); draw(); }, 20); // Assign to variable
        updateLivesDisplay(); // Initial display of lives
        document.getElementById('highScoreValueDisplay').textContent = highScore; // Initial display of high score

        // Start background music when game starts
        window.addEventListener('load', () => {
            audioElements.backgroundMusic.play().catch(error => console.log('Initial background music play failed:', error));
        });
    </script>
</body>
</html>