<!DOCTYPE html>
<html>
<head>
    <title>Pac-Man</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <style>
        body {
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Ensure full viewport height */
            margin: 0; /* Remove default body margin */
            font-family: monospace; /* Added monospace font */
            font-size: 13px;
            color: white;
        }
        #gameContainer {
            display: flex;
            flex-direction: column; /* Stack info area and canvas vertically */
            align-items: center; /* Center items horizontally within the container */
        }
        #infoAreaTop {
            margin-bottom: 10px; /* Space between score and canvas */
            width: 420px; /* Match canvas width for alignment */
            display: flex;
            flex-direction: row;
            align-items: flex-start; /* Align tops of child blocks */
            position: relative; /* For positioning highScoreArea */
        }
        /* Styles for the new score display structure */
        #player1ScoreArea {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 20px;
        }

        #highScoreArea {
            display: flex;
            flex-direction: column;
            align-items: center; /* Aligns "HIGH SCORE" and its value to the center */
            position: absolute;
            left: 50%; /* Center horizontally within #infoAreaTop */
            transform: translateX(-50%);
            top: 0; /* Align with the top of #infoAreaTop's content */
        }

        #oneUpText, #highScoreLabel {
            margin-bottom: 2px; /* Small space between label and value */
        }

        #scoreValue, #highScoreValueDisplay {
            /* Values inherit text styling, specific styling can be added here if needed */
        }
        /* End of new score display styles */
        #infoAreaFooter {
            margin-top: 10px; /* Space between score and canvas */
            width: 420px; /* Match canvas width for alignment */
            display: flex; /* Added for centering children */
            flex-direction: column; /* Stack children vertically */
            /* align-items: center; */ /* Removed to allow children to self-align */
            justify-content: center;
        }
        #livesDisplay {
            margin-left: 20px;
            display: flex;
            align-self: flex-start; /* Align this item to the start (left) */
        }
        .lifeIcon {
            margin-right: 5px;
        }
        #insertCreditArea {
            display: flex;
            flex-direction: column;
            align-items: center; /* Centers its internal spans */
            align-self: center; /* Center this block within the parent */
            display: none; /* Hide by default */
        }
        /* Optional: if you want to style the spans specifically */
        /* #insertCreditLabel, #insertCreditHelpText { */
        /* styles here */
        /* } */
        canvas { border: 1px solid black; background: black; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="infoAreaTop">
            <div id="player1ScoreArea">
                <span id="oneUpText">1UP</span>
                <span id="scoreValue">0</span>
            </div>
            <div id="highScoreArea">
                <span id="highScoreLabel">HIGH SCORE</span>
                <span id="highScoreValueDisplay">12410</span>
            </div>
        </div>
        <canvas id="gameCanvas" width="420" height="420"></canvas>
        <div id="infoAreaFooter">
            <div id="livesDisplay"></div>
            <div id="insertCreditArea">
                <span id="insertCreditLabel">INSERT CREDIT</span>
                <span id="insertCreditHelpText">(Press 1)</span>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        window.gameOver = false; // Initialize gameOver flag
        let mouthOpen = true; // Track if Pac-Man's mouth is open or closed
        let mouthFrameCounter = 0; // For controlling mouth animation speed
        const MOUTH_ANIMATION_FRAMES = 10; // Toggle mouth every 10 frames (10 * 20ms = 200ms)
        let extraLives = 5; // Initialize extraLives (e.g., 5 extra lives means 6 total chances)
        let powerUpActive = false;
        let powerUpTimer = 0;
        const powerUpDuration = 10000; // 10 seconds
        let powerPelletVisible = true; // Added for blinking effect
        let powerPelletBlinkTimer = 0; // Timer for blinking
        const POWER_PELLET_BLINK_INTERVAL = 400; // Blink every 0.5 second (500ms)

        // Maze layout (1 = wall, 0 = path/dot, 2 = eaten dot, 3 = ghost spawn point, 4 = power pellet)
        const originalMaze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], 
            [1,0,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,1,2,1,2,1,1,1,1,0,1,1,1,1],
            [1,1,1,1,0,1,2,2,2,2,2,2,2,2,2,1,0,1,1,1,1], 
            [1,1,1,1,0,1,2,1,1,3,3,3,1,1,2,1,0,1,1,1,1], 
            [2,2,2,2,0,2,2,1,1,3,3,3,1,1,2,2,0,2,2,2,2], 
            [1,1,1,1,0,1,2,1,1,1,1,1,1,1,2,1,0,1,1,1,1], 
            [1,1,1,1,0,1,2,2,2,2,2,2,2,2,2,1,0,1,1,1,1],
            [1,1,1,1,0,1,2,1,1,1,1,1,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1], 
            [1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1], 
            [1,0,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,1], 
            [1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        const maze = JSON.parse(JSON.stringify(originalMaze));
        // Add power pellets at specific locations
        maze[2][1] = 4;
        maze[2][19] = 4;
        maze[15][1] = 4;
        maze[15][19] = 4;
        
        const tileSize = 20; // Updated tileSize for 20x20 grid
        let pacman = { x: 10 * tileSize, y: 15 * tileSize, dir: null, nextDir: null, speed: 2 }; // Pac-Man's pixel position, speed, and intended next direction
        let ghosts = [ // Updated ghosts with colors and new starting positions
            { x: 9 * tileSize, y: 8 * tileSize, color: 'red', speed: 1.5, dir: null },
            { x: 9 * tileSize, y: 9 * tileSize, color: 'pink', speed: 1.5, dir: null },
            { x: 10 * tileSize, y: 9 * tileSize, color: 'cyan', speed: 1.5, dir: null },
            { x: 10 * tileSize, y: 8 * tileSize, color: 'orange', speed: 1.5, dir: null }
        ];
        let score = 0;
        let highScore = parseInt(localStorage.getItem('pacmanHighScore')) || 0; // Load high score or default to 0
        
        function drawMaze() {
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    } else if (maze[y][x] === 0) {
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize/2, y * tileSize + tileSize/2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (maze[y][x] === 4 && powerPelletVisible) {
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize/2, y * tileSize + tileSize/2, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        function drawPacman() {
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            
            // Define mouth angles based on direction and mouth state
            let startAngle, endAngle;
            const currentDir = pacman.dir || 'right'; // Default to right if no direction yet
            
            if (mouthOpen) {
                // Wide open mouth
                if (currentDir === 'right') {
                    startAngle = 0.2 * Math.PI;
                    endAngle = 1.8 * Math.PI;
                } else if (currentDir === 'left') {
                    startAngle = 1.2 * Math.PI;
                    endAngle = 0.8 * Math.PI; 
                } else if (currentDir === 'up') {
                    startAngle = 1.7 * Math.PI;
                    endAngle = 1.3 * Math.PI;
                } else if (currentDir === 'down') {
                    startAngle = 0.7 * Math.PI;
                    endAngle = 0.3 * Math.PI;
                }
            } else {
                // Almost closed mouth
                if (currentDir === 'right') {
                    startAngle = 0.05 * Math.PI;
                    endAngle = 1.95 * Math.PI;
                } else if (currentDir === 'left') {
                    startAngle = 1.05 * Math.PI;
                    endAngle = 0.95 * Math.PI; 
                } else if (currentDir === 'up') {
                    startAngle = 1.55 * Math.PI;
                    endAngle = 1.45 * Math.PI;
                } else if (currentDir === 'down') {
                    startAngle = 0.55 * Math.PI;
                    endAngle = 0.45 * Math.PI;
                }
            }

            ctx.arc(pacman.x + tileSize/2, pacman.y + tileSize/2, tileSize/2, startAngle, endAngle);
            ctx.lineTo(pacman.x + tileSize/2, pacman.y + tileSize/2);
            ctx.fill();
        }
        
        function drawGhosts() {
            ghosts.forEach(ghost => {
                let ghostFillStyle = ghost.color; // Normal color by default
                let isVulnerableLooking = false; // Flag for vulnerable appearance

                if (powerUpActive && ghost.isVulnerable && !ghost.isEyes) {
                    ghostFillStyle = 'blue'; // Vulnerable ghost color
                    isVulnerableLooking = true;
                } else if (ghost.isEyes) {
                    ghostFillStyle = 'white'; // Eyes only when eaten
                }
                ctx.fillStyle = ghostFillStyle;

                const bodyHeight = tileSize * 0.6;
                const headRadius = tileSize / 2;

                if (ghost.isEyes) {
                    // Draw only eyes
                    const eyeRadius = tileSize / 8;
                    const eyeOffsetX = tileSize / 4;
                    // Eyes should be centered on the ghost's pixel position
                    const eyeBaseY = ghost.y + tileSize / 2 - eyeRadius;


                    // Left eye
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(ghost.x + eyeOffsetX, eyeBaseY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(ghost.x + eyeOffsetX, eyeBaseY, eyeRadius / 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Right eye
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(ghost.x + tileSize - eyeOffsetX, eyeBaseY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(ghost.x + tileSize - eyeOffsetX, eyeBaseY, eyeRadius / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Ghost body/head drawing logic using ghost.x and ghost.y directly
                    const gx = ghost.x;
                    const gy = ghost.y;
                    const R = tileSize / 2; // headRadius
                    const bodyOverallHeight = tileSize * 0.6; 
                    const bodyTopY = gy + R; 

                    const waveEffectHeight = bodyOverallHeight / 3;
                    const upperStraightSkirtHeight = bodyOverallHeight - waveEffectHeight;

                    const wavePeakY = bodyTopY + upperStraightSkirtHeight; 
                    const waveValleyY = bodyTopY + bodyOverallHeight;      

                    ctx.beginPath();
                    ctx.arc(gx + R, bodyTopY, R, Math.PI, 0);
                    ctx.lineTo(gx + tileSize, wavePeakY);
                    ctx.lineTo(gx + (5 * tileSize / 6), waveValleyY); 
                    ctx.lineTo(gx + (2 * tileSize / 3), wavePeakY);   
                    ctx.lineTo(gx + (tileSize / 2), waveValleyY);     
                    ctx.lineTo(gx + (tileSize / 3), wavePeakY);       
                    ctx.lineTo(gx + (tileSize / 6), waveValleyY);     
                    ctx.lineTo(gx + 0, wavePeakY);                    
                    ctx.lineTo(gx + 0, bodyTopY);
                    ctx.closePath();
                    ctx.fill(); 

                    // Draw eyes (and mouth if vulnerable)
                    const eyeRadius = tileSize / 8;
                    const eyeOffsetX = tileSize / 4;
                    const eyeBaseY = ghost.y + tileSize / 2.5; 
                    
                    // Common white part for both eyes - must be drawn for both normal and vulnerable
                    ctx.fillStyle = 'white';
                    // Left eye (white part)
                    ctx.beginPath();
                    ctx.arc(ghost.x + eyeOffsetX, eyeBaseY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Right eye (white part)
                    ctx.beginPath();
                    ctx.arc(ghost.x + tileSize - eyeOffsetX, eyeBaseY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();

                    if (isVulnerableLooking) {
                        // Draw vulnerable mouth (no pupils)
                        ctx.strokeStyle = 'white'; 
                        ctx.lineWidth = 1; // Sharp pixel line
                        ctx.beginPath();
                        const mouthWidth = tileSize * 0.5; // Width of the mouth
                        const mouthSegments = 4; // Number of segments for the W-shape
                        const mouthSegmentWidth = mouthWidth / mouthSegments;
                        const mouthAmplitude = tileSize / 7; // Depth of the jags
                        const mouthYLine = eyeBaseY + eyeRadius + tileSize / 8; // Y position of the mouth's top line

                        const mouthStartX = ghost.x + (tileSize - mouthWidth) / 2; // Center the mouth horizontally

                        ctx.moveTo(mouthStartX, mouthYLine);
                        ctx.lineTo(mouthStartX + mouthSegmentWidth, mouthYLine + mouthAmplitude); // Jag down
                        ctx.lineTo(mouthStartX + 2 * mouthSegmentWidth, mouthYLine); // Jag up to center line
                        ctx.lineTo(mouthStartX + 3 * mouthSegmentWidth, mouthYLine + mouthAmplitude); // Jag down
                        ctx.lineTo(mouthStartX + 4 * mouthSegmentWidth, mouthYLine); // Jag up to end
                        ctx.stroke();
                    } else {
                        // Draw normal pupils
                        let pupilOffsetX = 0;
                        let pupilOffsetY = 0;
                        const currentGhostDir = ghost.dir || 'right'; // Default to right if no direction

                        if (currentGhostDir === 'right') {
                            pupilOffsetX = eyeRadius / 2;
                        } else if (currentGhostDir === 'left') {
                            pupilOffsetX = -eyeRadius / 2;
                        } else if (currentGhostDir === 'up') {
                            pupilOffsetY = -eyeRadius / 2;
                        } else if (currentGhostDir === 'down') {
                            pupilOffsetY = eyeRadius / 2;
                        }

                        ctx.fillStyle = 'black';
                        // Left pupil
                        ctx.beginPath();
                        ctx.arc(ghost.x + eyeOffsetX + pupilOffsetX, eyeBaseY + pupilOffsetY, eyeRadius / 2, 0, Math.PI * 2);
                        ctx.fill();

                        // Right pupil
                        ctx.beginPath();
                        ctx.arc(ghost.x + tileSize - eyeOffsetX + pupilOffsetX, eyeBaseY + pupilOffsetY, eyeRadius / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }
        
        function drawMiniPacman(ctx, x, y) {
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(x, y, 6, 1.2 * Math.PI, 0.8 * Math.PI);
            ctx.lineTo(x, y);
            ctx.fill();
        }

        function updateLivesDisplay() {
            const livesDisplay = document.getElementById('livesDisplay');
            livesDisplay.innerHTML = '';
            for (let i = 0; i < extraLives; i++) { // Display extraLives icons
                const canvas = document.createElement('canvas');
                canvas.className = 'lifeIcon';
                canvas.width = 15;
                canvas.height = 15;
                const miniCtx = canvas.getContext('2d');
                drawMiniPacman(miniCtx, 7, 7);
                livesDisplay.appendChild(canvas);
            }
        }
        
        function update() {
            if (window.gameOver) return;

            // Check for Power-Up Expiration
            if (powerUpActive && (Date.now() - powerUpTimer > powerUpDuration)) {
                powerUpActive = false;
                powerUpTimer = 0; // Reset timer
                ghosts.forEach(ghost => {
                    ghost.isVulnerable = false; // Revert ghosts to normal (not vulnerable)
                    // Note: isEyes state is handled separately when ghosts are eaten and return home
                });
            }

            // Mouth animation
            mouthFrameCounter++;
            if (mouthFrameCounter >= MOUTH_ANIMATION_FRAMES) {
                mouthOpen = !mouthOpen;
                mouthFrameCounter = 0;
            }

            // Power Pellet Blinking Logic
            const currentTime = Date.now();
            if (currentTime - powerPelletBlinkTimer > POWER_PELLET_BLINK_INTERVAL) {
                powerPelletVisible = !powerPelletVisible;
                powerPelletBlinkTimer = currentTime;
            }

            const mazeWidthPx = maze[0].length * tileSize;
            const mazeHeightPx = maze.length * tileSize;
            const TILE_CENTER_OFFSET = tileSize / 2;

            // --- PAC-MAN MOVEMENT --- 
            let currentPacmanTileX = Math.floor(pacman.x / tileSize);
            let currentPacmanTileY = Math.floor(pacman.y / tileSize);
            let pacmanCenterX = pacman.x + TILE_CENTER_OFFSET;
            let pacmanCenterY = pacman.y + TILE_CENTER_OFFSET;

            // Check if Pac-Man is aligned with the grid for turning
            const isAlignedX = pacman.x % tileSize === 0;
            const isAlignedY = pacman.y % tileSize === 0;

            // Try to change direction if a new direction is queued and Pac-Man is aligned
            if (pacman.nextDir && isAlignedX && isAlignedY) {
                let testPixelX = pacman.x;
                let testPixelY = pacman.y;
                let testTileX = currentPacmanTileX;
                let testTileY = currentPacmanTileY;

                if (pacman.nextDir === 'left') { testPixelX -= pacman.speed; testTileX--; }
                else if (pacman.nextDir === 'right') { testPixelX += pacman.speed; testTileX++; }
                else if (pacman.nextDir === 'up') { testPixelY -= pacman.speed; testTileY--; }
                else if (pacman.nextDir === 'down') { testPixelY += pacman.speed; testTileY++; }

                if (testTileX >= 0 && testTileX < maze[0].length && testTileY >= 0 && testTileY < maze.length &&
                    maze[testTileY][testTileX] !== 1 && maze[testTileY][testTileX] !== 3) {
                    pacman.dir = pacman.nextDir;
                    pacman.nextDir = null;
                }
            }

            let intendedPixelX = pacman.x;
            let intendedPixelY = pacman.y;

            if (pacman.dir === 'left') intendedPixelX -= pacman.speed;
            else if (pacman.dir === 'right') intendedPixelX += pacman.speed;
            else if (pacman.dir === 'up') intendedPixelY -= pacman.speed;
            else if (pacman.dir === 'down') intendedPixelY += pacman.speed;
            
            // Determine the tile Pac-Man is trying to move into
            let targetTileX = currentPacmanTileX;
            let targetTileY = currentPacmanTileY;

            if (pacman.dir === 'left') targetTileX = Math.floor(intendedPixelX / tileSize);
            else if (pacman.dir === 'right') targetTileX = Math.ceil((intendedPixelX) / tileSize); // Use intendedPixelX, not pacman.x
            else if (pacman.dir === 'up') targetTileY = Math.floor(intendedPixelY / tileSize);
            else if (pacman.dir === 'down') targetTileY = Math.ceil((intendedPixelY) / tileSize); // Use intendedPixelY, not pacman.y

            // Tunnel Logic - applied before wall collision for movement
            const tunnelYTile = 9;
            const isInTunnelCorridor = Math.floor(pacmanCenterY / tileSize) === tunnelYTile;

            if (isInTunnelCorridor && pacman.dir === 'left' && pacmanCenterX - pacman.speed <= TILE_CENTER_OFFSET) { // Moving left into tunnel exit
                 if (currentPacmanTileX === 0) { // Check if at the leftmost tile
                    pacman.x = mazeWidthPx - tileSize; // Emerge from right, position aligned
                    intendedPixelX = pacman.x; // Update intended for further logic if any
                 }
            } else if (isInTunnelCorridor && pacman.dir === 'right' && pacmanCenterX + pacman.speed >= mazeWidthPx - TILE_CENTER_OFFSET) { // Moving right into tunnel exit
                if (currentPacmanTileX === maze[0].length -1) { // Check if at the rightmost tile
                    pacman.x = 0; // Emerge from left, position aligned
                    intendedPixelX = pacman.x; // Update intended for further logic if any
                }
            }

            // Wall Collision and Movement
            if (pacman.dir) {
                let canMove = true;
                // Recalculate current tile based on potentially updated pacman.x from tunnel
                currentPacmanTileX = Math.floor(pacman.x / tileSize);
                currentPacmanTileY = Math.floor(pacman.y / tileSize);

                if (pacman.dir === 'left') {
                    if (intendedPixelX < 0 || (isAlignedY && maze[currentPacmanTileY][currentPacmanTileX - 1] === 1 && intendedPixelX < currentPacmanTileX * tileSize)) {
                        intendedPixelX = currentPacmanTileX * tileSize;
                        if (isAlignedY && pacman.nextDir && (pacman.nextDir === 'up' || pacman.nextDir === 'down')) { /* allow turn attempt next cycle */ } else { /* pacman.dir = null; */ }
                    }
                } else if (pacman.dir === 'right') {
                    if (intendedPixelX + tileSize > mazeWidthPx || (isAlignedY && maze[currentPacmanTileY][currentPacmanTileX + 1] === 1 && intendedPixelX + tileSize > (currentPacmanTileX + 1) * tileSize)) {
                        intendedPixelX = currentPacmanTileX * tileSize;
                        if (isAlignedY && pacman.nextDir && (pacman.nextDir === 'up' || pacman.nextDir === 'down')) { /* allow turn attempt next cycle */ } else { /* pacman.dir = null; */ }
                    }
                } else if (pacman.dir === 'up') {
                    if (intendedPixelY < 0 || (isAlignedX && maze[currentPacmanTileY - 1][currentPacmanTileX] === 1 && intendedPixelY < currentPacmanTileY * tileSize)) {
                        intendedPixelY = currentPacmanTileY * tileSize;
                        if (isAlignedX && pacman.nextDir && (pacman.nextDir === 'left' || pacman.nextDir === 'right')) { /* allow turn attempt next cycle */ } else { /* pacman.dir = null; */ }
                    }
                } else if (pacman.dir === 'down') {
                    if (intendedPixelY + tileSize > mazeHeightPx || (isAlignedX && maze[currentPacmanTileY + 1][currentPacmanTileX] === 1 && intendedPixelY + tileSize > (currentPacmanTileY + 1) * tileSize)) {
                        intendedPixelY = currentPacmanTileY * tileSize;
                        if (isAlignedX && pacman.nextDir && (pacman.nextDir === 'left' || pacman.nextDir === 'right')) { /* allow turn attempt next cycle */ } else { /* pacman.dir = null; */ }
                    }
                }
                
                // Check if the CENTER of pacman in its INTENDED position would be in a wall tile
                let intendedCenterX = intendedPixelX + TILE_CENTER_OFFSET;
                let intendedCenterY = intendedPixelY + TILE_CENTER_OFFSET;
                let intendedNextTileX = Math.floor(intendedCenterX / tileSize);
                let intendedNextTileY = Math.floor(intendedCenterY / tileSize);
                
                if (pacman.dir === 'left' || pacman.dir === 'right') {
                     if (maze[intendedNextTileY]?.[intendedNextTileX] === 1 || maze[intendedNextTileY]?.[intendedNextTileX] === 3) {
                        pacman.x = (pacman.dir === 'left' ? (intendedNextTileX + 1) * tileSize : intendedNextTileX * tileSize - tileSize);
                        // pacman.dir = null; // Stop Pacman
                    } else {
                        pacman.x = intendedPixelX;
                    }
                } else if (pacman.dir === 'up' || pacman.dir === 'down') {
                    if (maze[intendedNextTileY]?.[intendedNextTileX] === 1 || maze[intendedNextTileY]?.[intendedNextTileX] === 3) {
                        pacman.y = (pacman.dir === 'up' ? (intendedNextTileY + 1) * tileSize : intendedNextTileY * tileSize - tileSize);
                        // pacman.dir = null; // Stop Pacman
                    } else {
                        pacman.y = intendedPixelY;
                    }
                }

            }

            // Clamp Pac-Man's position to be within canvas boundaries (after tunnel and movement)
            pacman.x = Math.max(0, Math.min(pacman.x, mazeWidthPx - tileSize));
            pacman.y = Math.max(0, Math.min(pacman.y, mazeHeightPx - tileSize));

            // --- DOT EATING --- (Remains largely the same, uses center of Pac-Man)
            const eatingTileX = Math.floor((pacman.x + TILE_CENTER_OFFSET) / tileSize);
            const eatingTileY = Math.floor((pacman.y + TILE_CENTER_OFFSET) / tileSize);

            if (eatingTileX >= 0 && eatingTileX < maze[0].length &&
                eatingTileY >= 0 && eatingTileY < maze.length) {
                if (maze[eatingTileY][eatingTileX] === 0) { // Dot
                    maze[eatingTileY][eatingTileX] = 2; // Mark as eaten
                    score += 10;
                } else if (maze[eatingTileY][eatingTileX] === 4) { // Power pellet
                    maze[eatingTileY][eatingTileX] = 2; // Mark as eaten
                    score += 50;
                    powerUpActive = true;
                    powerUpTimer = Date.now();
                    ghosts.forEach(ghost => {
                        if (!ghost.isEyes) { // Only make non-eaten ghosts vulnerable
                            ghost.isVulnerable = true;
                        }
                    });
                }
            }

            ghosts.forEach(ghost => {
                const ghostTileX = Math.round(ghost.x / tileSize);
                const ghostTileY = Math.round(ghost.y / tileSize);
                const pacmanCurrentTileX = Math.round(pacman.x / tileSize); // Pacman's current tile
                const pacmanCurrentTileY = Math.round(pacman.y / tileSize); // Pacman's current tile

                if (ghost.isEyes) {
                    const homeTargetX = 10 * tileSize; // Ghost home in pixels
                    const homeTargetY = 9 * tileSize;  // Ghost home in pixels
                    
                    let dx = 0, dy = 0;
                    if (ghost.x < homeTargetX) dx = ghost.speed;
                    else if (ghost.x > homeTargetX) dx = -ghost.speed;
                    if (ghost.y < homeTargetY) dy = ghost.speed;
                    else if (ghost.y > homeTargetY) dy = -ghost.speed;

                    // More precise check for reaching home
                    if (Math.abs(ghost.x - homeTargetX) < ghost.speed && Math.abs(ghost.y - homeTargetY) < ghost.speed) {
                        ghost.x = homeTargetX;
                        ghost.y = homeTargetY;
                        ghost.isEyes = false;
                        ghost.isVulnerable = false; // Ensure respawned ghost is not vulnerable
                        ghost.dir = null; // Reset direction
                    } else {
                        // Move ghost eyes
                        ghost.x += dx;
                        ghost.y += dy;
                        // Set direction for pupil movement
                        if (dx > 0) ghost.dir = 'right'; else if (dx < 0) ghost.dir = 'left';
                        else if (dy > 0) ghost.dir = 'down'; else if (dy < 0) ghost.dir = 'up'; else ghost.dir = null;
                    }
                } else {
                    // Simple random movement for now, needs to be tile-aligned for turning
                    if ((ghost.x % tileSize < ghost.speed && ghost.x % tileSize > -ghost.speed) && 
                        (ghost.y % tileSize < ghost.speed && ghost.y % tileSize > -ghost.speed)) { // If aligned to grid
                        
                        ghost.x = Math.round(ghost.x / tileSize) * tileSize; // Snap to grid
                        ghost.y = Math.round(ghost.y / tileSize) * tileSize;

                        const possibleMoves = [];
                        const currentGhostTileX = Math.round(ghost.x / tileSize);
                        const currentGhostTileY = Math.round(ghost.y / tileSize);

                        // Check potential moves (Up, Down, Left, Right)
                        // Up
                        if (currentGhostTileY > 0 && maze[currentGhostTileY - 1][currentGhostTileX] !== 1 && ghost.dir !== 'down') possibleMoves.push({dx:0, dy:-ghost.speed, dir: 'up'});
                        // Down
                        if (currentGhostTileY < maze.length - 1 && maze[currentGhostTileY + 1][currentGhostTileX] !== 1 && ghost.dir !== 'up') possibleMoves.push({dx:0, dy:ghost.speed, dir: 'down'});
                        // Left
                        if (currentGhostTileX > 0 && maze[currentGhostTileY][currentGhostTileX - 1] !== 1 && ghost.dir !== 'right') possibleMoves.push({dx:-ghost.speed, dy:0, dir: 'left'});
                        // Right
                        if (currentGhostTileX < maze[0].length - 1 && maze[currentGhostTileY][currentGhostTileX + 1] !== 1 && ghost.dir !== 'left') possibleMoves.push({dx:ghost.speed, dy:0, dir: 'right'});
                        
                        if (possibleMoves.length > 0) {
                            const chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                            ghost.currentMove = chosenMove; // Store the chosen move
                            ghost.dir = chosenMove.dir; // Update ghost's direction property
                        } else {
                            // If no moves, try to reverse (e.g. dead end)
                             if (ghost.dir === 'up') ghost.currentMove = {dx:0, dy:ghost.speed, dir: 'down'};
                             else if (ghost.dir === 'down') ghost.currentMove = {dx:0, dy:-ghost.speed, dir: 'up'};
                             else if (ghost.dir === 'left') ghost.currentMove = {dx:ghost.speed, dy:0, dir: 'right'};
                             else if (ghost.dir === 'right') ghost.currentMove = {dx:-ghost.speed, dy:0, dir: 'left'};
                             if(ghost.currentMove) ghost.dir = ghost.currentMove.dir;
                        }
                    }
                    // Apply movement based on stored move
                    if (ghost.currentMove) {
                        ghost.x += ghost.currentMove.dx;
                        ghost.y += ghost.currentMove.dy;
                    }
                }

                // Collision with Pac-Man (pixel-based, using a small tolerance)
                const collisionThreshold = tileSize * 0.75; // If centers are within 3/4 of a tile
                if (Math.abs(pacman.x - ghost.x) < collisionThreshold && Math.abs(pacman.y - ghost.y) < collisionThreshold && !window.gameOver) {
                    if (powerUpActive && ghost.isVulnerable && !ghost.isEyes) {
                        ghost.isEyes = true;
                        ghost.isVulnerable = false; // Can't be eaten again
                        score += 200;
                        // No need to move ghost to home here, eye logic will handle it
                    } else if (!ghost.isEyes) {
                        extraLives--;
                        if (extraLives >= 0) { // >= 0 because extraLives = 0 means 1 actual life left
                            // Reset Pac-Man's position (pixel-based)
                            pacman = { x: 10 * tileSize, y: 15 * tileSize, dir: null, nextDir: null, speed: 2 };
                            // Reset Ghosts' positions (pixel-based)
                            ghosts.forEach(g => {
                                if (g.color === 'red') { g.x = 9 * tileSize; g.y = 8 * tileSize; }
                                else if (g.color === 'pink') { g.x = 9 * tileSize; g.y = 9 * tileSize; }
                                else if (g.color === 'cyan') { g.x = 10 * tileSize; g.y = 9 * tileSize; }
                                else if (g.color === 'orange') { g.x = 10 * tileSize; g.y = 8 * tileSize; }
                                g.isEyes = false;
                                g.isVulnerable = false;
                                g.dir = null;
                                g.currentMove = null;
                                g.speed = 1.5; // Ensure speed is reset
                            });
                            updateLivesDisplay();
                        } else {
                            window.gameOver = true;
                            localStorage.setItem('pacmanHighScore', highScore);
                            document.getElementById('insertCreditArea').style.display = 'flex'; // Show insert credit text
                        }
                    }
                }
            });

            // Update high score if current score is higher
            if (score > highScore) {
                highScore = score;
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            drawPacman();
            drawGhosts();
            // Update the score in the dedicated HTML element
            document.getElementById('scoreValue').textContent = score;
            document.getElementById('highScoreValueDisplay').textContent = highScore; // Display high score

            if (window.gameOver) {
                ctx.fillStyle = 'red';
                ctx.font = '30px monospace'; // Using monospace to match existing style
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle'; // For better vertical alignment
                const yGameOverPosition = (8 * tileSize) + (tileSize / 2); // Centered in Y-tile index 8 (ghost house door)
                ctx.fillText('GAME OVER', canvas.width / 2, yGameOverPosition);
            }
        }
        
        function resetGame() {
            // Save high score before resetting anything else
            localStorage.setItem('pacmanHighScore', highScore);

            // Reset maze (restore all dots)
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    maze[y][x] = originalMaze[y][x];
                }
            }
            // Add power pellets
            maze[2][1] = 4;
            maze[2][19] = 4;
            maze[15][1] = 4;
            maze[15][19] = 4;
            
            // Reset Pac-Man
            pacman = { x: 10 * tileSize, y: 15 * tileSize, dir: null, nextDir: null, speed: 2 };
            
            // Reset ghosts
            ghosts = [
                { x: 9 * tileSize, y: 8 * tileSize, color: 'red', isEyes: false, isVulnerable: false, dir: null, speed: 1.5, currentMove: null },
                { x: 9 * tileSize, y: 9 * tileSize, color: 'pink', isEyes: false, isVulnerable: false, dir: null, speed: 1.5, currentMove: null },
                { x: 10 * tileSize, y: 9 * tileSize, color: 'cyan', isEyes: false, isVulnerable: false, dir: null, speed: 1.5, currentMove: null },
                { x: 10 * tileSize, y: 8 * tileSize, color: 'orange', isEyes: false, isVulnerable: false, dir: null, speed: 1.5, currentMove: null }
            ];
            
            // Reset score
            score = 0;
            
            // Reset lives
            extraLives = 5; // Reset to initial number of extra lives
            updateLivesDisplay();
            
            // Reset game state
            window.gameOver = false;
            powerUpActive = false;
            powerUpTimer = 0;
            mouthOpen = true; // Reset mouth state
            mouthFrameCounter = 0; // Reset mouth animation counter
            document.getElementById('insertCreditArea').style.display = 'none'; // Hide insert credit text
            
            // If the game loop was stopped, restart it
            if (!gameLoopInterval) {
                gameLoopInterval = setInterval(() => { update(); draw(); }, 20);
            }
            
            // Update display
            draw();
        }
        
        // Game controls
        document.addEventListener('keydown', e => {
            let newNextDir = null;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') newNextDir = 'right';
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') newNextDir = 'left';
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') newNextDir = 'down';
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') newNextDir = 'up';

            if (newNextDir) {
                pacman.nextDir = newNextDir; // Queue the direction
            }
            
            // Check for '1' to restart the game when game over
            if (e.key === '1' && window.gameOver) {
                resetGame();
            }
        });
        
        let gameLoopInterval = setInterval(() => { update(); draw(); }, 20); // Assign to variable
        updateLivesDisplay(); // Initial display of lives
        document.getElementById('highScoreValueDisplay').textContent = highScore; // Initial display of high score
    </script>
</body>
</html>